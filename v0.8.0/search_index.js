var documenterSearchIndex = {"docs":
[{"location":"input/#Input","page":"Input","title":"Input","text":"","category":"section"},{"location":"input/#Keyboard","page":"Input","title":"Keyboard","text":"","category":"section"},{"location":"input/","page":"Input","title":"Input","text":"A keystroke sends a signal corresponding to the physical key being pressed. This signal is then translated into a symbol by a windowing API. For example, if the key KP6 (6 on the keypad) is pressed, the symbol may correspond to kp_6 or kp_right depending on whether the num lock was on or off. Therefore, the translation of the key to a symbol depends on a state, referred to as keyboard state. It encodes whether shift, control, alt and super modes, also referred to as modifier state, are enabled, along with the num lock and caps lock among others.","category":"page"},{"location":"input/","page":"Input","title":"Input","text":"A symbol does not necessarily represent a printable character, particularly for keys not in the alphanumeric set. However, it is often desired to get a printable character from a keystroke as an input. For non-printable symbols, this input is simply the null character.","category":"page"},{"location":"input/","page":"Input","title":"Input","text":"The translation from physical keystroke to key symbol depends on the state of the keyboard, but also on its associated keymap. A keymap, as its name implies, partially defines a mapping from keystrokes to key symbols. It is separate from keyboard state, and can be described using a keyboard layout, along with country and language codes. Keymaps can be changed dynamically, for example with super + space on Ubuntu 20.10, usually to switch between languages.","category":"page"},{"location":"input/","page":"Input","title":"Input","text":"To summarize, a physical keystroke is converted to a key symbol using a keymap and knowing the keyboard state. It may be printable or not, in which case the corresponding input character is null.","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [WindowAbstractions]\nPrivate = true","category":"page"},{"location":"api/#WindowAbstractions.BUTTON_PRESSED","page":"API","title":"WindowAbstractions.BUTTON_PRESSED","text":"A mouse button was released.\n\n\n\n\n\n","category":"constant"},{"location":"api/#WindowAbstractions.BUTTON_RELEASED","page":"API","title":"WindowAbstractions.BUTTON_RELEASED","text":"The pointer entered the window area.\n\n\n\n\n\n","category":"constant"},{"location":"api/#WindowAbstractions.KEY_PRESSED","page":"API","title":"WindowAbstractions.KEY_PRESSED","text":"A key was pressed. Note that some key combinations can be reserved by the OS, so they don't trigger the corresponding event. On Ubuntu 20.04, this is for example the case with some combinations of the form alt+fkey such as alt+f4.\n\n\n\n\n\n","category":"constant"},{"location":"api/#WindowAbstractions.KEY_RELEASED","page":"API","title":"WindowAbstractions.KEY_RELEASED","text":"A key was released.\n\n\n\n\n\n","category":"constant"},{"location":"api/#WindowAbstractions.NO_EVENT","page":"API","title":"WindowAbstractions.NO_EVENT","text":"Signals an absence of event.\n\n\n\n\n\n","category":"constant"},{"location":"api/#WindowAbstractions.POINTER_ENTERED","page":"API","title":"WindowAbstractions.POINTER_ENTERED","text":"A mouse button was pressed.\n\n\n\n\n\n","category":"constant"},{"location":"api/#WindowAbstractions.POINTER_EXITED","page":"API","title":"WindowAbstractions.POINTER_EXITED","text":"The pointer left the window area.\n\n\n\n\n\n","category":"constant"},{"location":"api/#WindowAbstractions.POINTER_MOVED","page":"API","title":"WindowAbstractions.POINTER_MOVED","text":"The pointer moves in the window.\n\n\n\n\n\n","category":"constant"},{"location":"api/#WindowAbstractions.WINDOW_CLOSED","page":"API","title":"WindowAbstractions.WINDOW_CLOSED","text":"The window was closed, e.g. manually by the user or by a programmatic action.\n\n\n\n\n\n","category":"constant"},{"location":"api/#WindowAbstractions.WINDOW_EXPOSED","page":"API","title":"WindowAbstractions.WINDOW_EXPOSED","text":"A window was exposed to the screen; either right after creation, or when it was previously hidden and then visible again.\n\n\n\n\n\n","category":"constant"},{"location":"api/#WindowAbstractions.WINDOW_GAINED_FOCUS","page":"API","title":"WindowAbstractions.WINDOW_GAINED_FOCUS","text":"The window gained focus.\n\n\n\n\n\n","category":"constant"},{"location":"api/#WindowAbstractions.WINDOW_INVALID","page":"API","title":"WindowAbstractions.WINDOW_INVALID","text":"The window is detected as invalid (for example, when closed externally).\n\nThe conditions for tagging a window as invalid depend on the windowing API used. It is typically used to signal that a window crashed or does not exist, but for which an event was reported. It may however not possible to know exactly why or when a window becomes invalid. For example, the X11 protocol does not offer a way to check for window validity, since the window may get invalidated by the time the X server answer comes back. Windows that are tagged invalid should be terminated.\n\n\n\n\n\n","category":"constant"},{"location":"api/#WindowAbstractions.WINDOW_LOST_FOCUS","page":"API","title":"WindowAbstractions.WINDOW_LOST_FOCUS","text":"The window lost focus.\n\n\n\n\n\n","category":"constant"},{"location":"api/#WindowAbstractions.WINDOW_RESIZED","page":"API","title":"WindowAbstractions.WINDOW_RESIZED","text":"The window was resized.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Core.Type-Tuple{AbstractWindowManager}","page":"API","title":"Core.Type","text":"(::Type{<:AbstractWindow})(wm::AbstractWindowManager; kwargs...)\n\nCreate a window.\n\n\n\n\n\n","category":"method"},{"location":"api/#WindowAbstractions.AbstractWindow","page":"API","title":"WindowAbstractions.AbstractWindow","text":"Abstract window type.\n\nabstract type AbstractWindow\n\n\n\n\n\n","category":"type"},{"location":"api/#WindowAbstractions.AbstractWindowManager","page":"API","title":"WindowAbstractions.AbstractWindowManager","text":"Entity that manages windows.\n\nabstract type AbstractWindowManager\n\n\n\n\n\n","category":"type"},{"location":"api/#WindowAbstractions.Event","page":"API","title":"WindowAbstractions.Event","text":"Generic event structure identified by its type (see EventType) and which may hold data depending on the type of event.\n\nThe type of data follows the association (with respect to the event type):\n\nKEY_PRESSED or KEY_RELEASED: KeyEvent, accessible with event.key_event\nBUTTON_PRESSED or BUTTON_RELEASED: MouseEvent, accessible with event.mouse_event\nPOINTER_MOVED: PointerState, accessible with event.pointer_state\nWINDOW_RESIZED: Tuple{Float64,Float64} # new dimensions, accessible with event.new_dimensions\nWINDOW_EXPOSED: Tuple{Float64,Float64} # area to redraw, accessible with event.area\nOther event types: Nothing\n\nstruct Event{W<:AbstractWindow}\n\ntype::EventType\ndata::Any\nlocation::Tuple{Float64, Float64}\ntime::Float64\nwindow::AbstractWindow\n\n\n\n\n\n","category":"type"},{"location":"api/#WindowAbstractions.EventQueue","page":"API","title":"WindowAbstractions.EventQueue","text":"Event queue meant to hold events to be processed by an application.\n\nThe event queue is bound to a window manager, and will be filled upon notification of low-level events sent by that window manager. Only high-level events will be recorded in the event queue, which are typically suited for use in applications.\n\nThe event queue is infinitely iterable, returning Events as they are received. When no events are available, the queue will either enter a sleeping state of approximately 1 ms (if sleep = true) or spin while yielding at every iteration.\n\nAny task iterating over the event queue is therefore a good candidate to be scheduled using an interactive thread from Julia 1.9 onwards.\n\nAlternatively, the event queue may be manually filled with collect_events! and processed using Base.isempty and Base.popfirst!.\n\nThe parameter record_history may be set to true to save all events that have been processed (either by iteration or manual Base.popfirst!). Implementations of window managers may extend save_history and replay_history to allow for the saving and replay of events that have been stored. Note that record_history will have to be set to true for save_history to work.\n\nstruct EventQueue{WM<:AbstractWindowManager, W<:AbstractWindow}\n\nwm::AbstractWindowManager\nevents::Array{Event{W}, 1} where W<:AbstractWindow\nhistory::Array{Event{W}, 1} where W<:AbstractWindow\nsleep::Bool\nrecord_history::Bool\n\n\n\n\n\n","category":"type"},{"location":"api/#WindowAbstractions.EventType","page":"API","title":"WindowAbstractions.EventType","text":"Type of input or window event which may occur on a particular window.\n\nThis type is defined as a bitmask, to make it easier to work with sets of events.\n\nstruct EventType <: BitMasks.BitMask{UInt32}\n\nval::UInt32\n\n\n\n\n\n","category":"type"},{"location":"api/#WindowAbstractions.KeyCombination","page":"API","title":"WindowAbstractions.KeyCombination","text":"Key binding associated to a character and a key modifier state.\n\nstruct KeyCombination\n\nkey::KeySymbol\nexact_modifiers::ModifierState\nsignificant_modifiers::ModifierState\n\n\n\n\n\n","category":"type"},{"location":"api/#WindowAbstractions.KeyEvent","page":"API","title":"WindowAbstractions.KeyEvent","text":"Details surrounding an event produced by a keystroke.\n\nstruct KeyEvent\n\nkey_name::Symbol: The name of the physical key.\n\nkey::KeySymbol: The symbol associated with the keystroke.\n\ninput::Char: Printable input (can be the empty string).\n\nmodifiers::ModifierState: Modifier state.\n\nconsumed_modifiers::ModifierState: Modifiers that were used when translating the physical key into a key symbol.\n\n\n\n\n\n","category":"type"},{"location":"api/#WindowAbstractions.KeySymbol","page":"API","title":"WindowAbstractions.KeySymbol","text":"Representation of a symbol that may be bound to a key, depending on a keyboard layout. It differs from the physical representation of a key, denoted by names such as AD01 which represent physical keys (in this case, q on a US keyboard). A key symbol is sent when a physical key is pressed, even if no input character is bound to the key. This structure provides a friendly symbol field, and a prettier description field (mostly used for printing). For example, the right arrow, with symbol :right_arrow (resp. :kp_right_arrow for keypad input), is represented by \"→\" (resp. \"→ (keypad)\").\n\nThere is no consistent representation, so the one provided here may differ from windowing API implementations.\n\nstruct KeySymbol\n\nname::Symbol\ndescription::Union{Char, String}\n\n\n\n\n\n","category":"type"},{"location":"api/#WindowAbstractions.MouseEvent","page":"API","title":"WindowAbstractions.MouseEvent","text":"A mouse press/release associated to a certain state.\n\nstruct MouseEvent\n\nbutton::MouseButton\nstate::MouseButton\n\n\n\n\n\n","category":"type"},{"location":"api/#WindowAbstractions.PointerState","page":"API","title":"WindowAbstractions.PointerState","text":"Context in which a pointer motion was performed, including active mouse buttons and keyboard modifiers.\n\nstruct PointerState\n\nstate::MouseButton\nmodifiers::ModifierState\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.close-Tuple{AbstractWindowManager, AbstractWindow}","page":"API","title":"Base.close","text":"close(wm::AbstractWindowManager, window::AbstractWindow)\n\nClose a window.\n\nclose(wm::AbstractWindowManager, _::AbstractWindow)\n\n\n\n\n\n\n","category":"method"},{"location":"api/#WindowAbstractions.collect_events!-Tuple{EventQueue}","page":"API","title":"WindowAbstractions.collect_events!","text":"Gather all pending events.\n\ncollect_events!(queue::EventQueue)\n\n\n\n\n\n\n","category":"method"},{"location":"api/#WindowAbstractions.dpi-Tuple{AbstractWindow}","page":"API","title":"WindowAbstractions.dpi","text":"Get window DPI.\n\ndpi(window::AbstractWindow)\n\n\n\n\n\n\n","category":"method"},{"location":"api/#WindowAbstractions.extent-Tuple{AbstractWindow}","page":"API","title":"WindowAbstractions.extent","text":"Window dimensions (width, height).\n\nextent(window::AbstractWindow)\n\n\n\n\n\n\n","category":"method"},{"location":"api/#WindowAbstractions.get_window-Tuple{AbstractWindowManager, Any}","page":"API","title":"WindowAbstractions.get_window","text":"Retrieve a window given an identifier id, would typically be an integer identifier, a handle or a name.\n\nget_window(wm::AbstractWindowManager, id)\n\n\n\n\n\n\n","category":"method"},{"location":"api/#WindowAbstractions.key_symbol-Tuple{Symbol}","page":"API","title":"WindowAbstractions.key_symbol","text":"Define an internal representation and a readable description for some key inputs.\n\nThe keys that are listed here are not exhaustive and only cover a very small subset of all possible keys.\n\nkey_symbol(name::Symbol) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"api/#WindowAbstractions.map_window-Tuple{AbstractWindow}","page":"API","title":"WindowAbstractions.map_window","text":"Map a window to the screen.\n\nmap_window(window::AbstractWindow)\n\n\n\n\n\n\n","category":"method"},{"location":"api/#WindowAbstractions.poll_for_events!-Tuple{EventQueue}","page":"API","title":"WindowAbstractions.poll_for_events!","text":"Non-blocking poll for events. Must return whether a client event was consumed, even if no Event is added to the queue.\n\npoll_for_events!(queue::EventQueue)\n\n\n\n\n\n\n","category":"method"},{"location":"api/#WindowAbstractions.replay_history","page":"API","title":"WindowAbstractions.replay_history","text":"replay_history(wm, events)\n\nReplay events generated by save_history on the provided window manager.\n\nDelays between events should be respected. The window manager is free to assume that no other event will be generated during the replay: user interactinos with the window while the replay is ongoing may affect the integrity of the replication.\n\nNote that any global state such as RNG is not saved; the application is responsible for managing state appropriately for effects outside of the event system.\n\n\n\n\n\n","category":"function"},{"location":"api/#WindowAbstractions.resize-Tuple{AbstractWindow, Any}","page":"API","title":"WindowAbstractions.resize","text":"Resize the window with extent reflecting the new (width, height).\n\nresize(window::AbstractWindow, extent)\n\n\n\n\n\n\n","category":"method"},{"location":"api/#WindowAbstractions.save_history","page":"API","title":"WindowAbstractions.save_history","text":"save_history(wm::WM, queue::EventQueue{WM}) -> Vector{<:Event}\n\nSave actions stored inside the event queue for later replay with replay_history.\n\nThe event queue must have been created with record_history = true.\n\n\n\n\n\n","category":"function"},{"location":"api/#WindowAbstractions.set_icon-Tuple{AbstractWindow, Any}","page":"API","title":"WindowAbstractions.set_icon","text":"Set window icon.\n\nset_icon(window::AbstractWindow, icon)\n\n\n\n\n\n\n","category":"method"},{"location":"api/#WindowAbstractions.set_icon_title-Tuple{AbstractWindow, Any}","page":"API","title":"WindowAbstractions.set_icon_title","text":"Set window icon title.\n\nset_icon_title(window::AbstractWindow, icon_title)\n\n\n\n\n\n\n","category":"method"},{"location":"api/#WindowAbstractions.set_title-Tuple{AbstractWindow, Any}","page":"API","title":"WindowAbstractions.set_title","text":"Set window title.\n\nset_title(window::AbstractWindow, title)\n\n\n\n\n\n\n","category":"method"},{"location":"api/#WindowAbstractions.unmap_window-Tuple{AbstractWindow}","page":"API","title":"WindowAbstractions.unmap_window","text":"Unmap a window from the screen.\n\nunmap_window(window::AbstractWindow)\n\n\n\n\n\n\n","category":"method"},{"location":"api/#WindowAbstractions.windows-Tuple{AbstractWindowManager}","page":"API","title":"WindowAbstractions.windows","text":"Retrieve all the AbstractWindows in use by wm.\n\nwindows(wm::AbstractWindowManager)\n\n\n\n\n\n\n","category":"method"},{"location":"api/#WindowAbstractions.@key_str-Tuple{Any}","page":"API","title":"WindowAbstractions.@key_str","text":"Construct a KeyCombination instance from a string as \"[<state_1>+[...<state_n>+]]<key>\". The string must be a list of elements separated by '+' characters, with only one key symbol at the end. For example, \"k\", \"alt+k\" and \"ctrl+alt+shift+f11\" are valid strings, but \"k+a\" is not. Casing is significant, as z and Z are different key symbols. For modifier strings, the casing should be lowercase, or will be forcefully converted into a lowercase string (reducing performance).\n\n\n\n\n\n","category":"macro"},{"location":"events/#Events","page":"Events","title":"Events","text":"","category":"section"},{"location":"events/","page":"Events","title":"Events","text":"Keystrokes, mouse buttons and pointer motions are associated to specific events, wrapped around an Event that adds information regarding the type of event, time, location and the window on which the event happened.","category":"page"},{"location":"events/","page":"Events","title":"Events","text":"For example, keystrokes are represented by KeyEvent structures, which contain all the details regarding the physical key that was pressed or released, along with context information and an interpretation of the associated key symbol. These include the code of the physical key, the symbol it was translated to, the associated input character, the active modifiers and the modifiers which were consumed during the translation.","category":"page"},{"location":"events/","page":"Events","title":"Events","text":"Events are meant to be generated by iteration of an EventQueue.","category":"page"},{"location":"intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Although window systems tend to be quite different from one another in their core API, they expose a common set of functionality. For example, setting the window title or size, and detecting input events (keyboard/mouse events) is something that can be done from any windowing API.","category":"page"},{"location":"intro/#Windowing-systems","page":"Introduction","title":"Windowing systems","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Some major windowing systems are described here:","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"X Window System: windowing system for Unix-like operating systems. The API is exposed through the X11 protocol, with the X11 and XCB libraries. The XCB.jl library is available and registered, serving as both a low-level interface to XCB and a high-level package using abstractions defined in this package.\nWayland: is aimed as a replacement to the old X window system, with better support for modern hardware features such as heterogeneous monitor refresh rates, high DPI monitors and HDR screens. Wayland.jl exists as a work in progress, which currently only implements a low-level interface to Wayland as a Wayland client.\nDesktop Window Manager: windowing system for Windows.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Many more exist, as can be seen on the Wikipedia page.","category":"page"},{"location":"#WindowAbstractions.jl","page":"Home","title":"WindowAbstractions.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Abstractions for windowing APIs. This library is intended for developers, and not for general use. It is currently only used by XCB.jl and Wayland.jl, but aims at being applicable to other windowing APIs such as Windows. Julia developers wrapping windowing APIs are encouraged to use and contribute to this library as much as possible.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"intro.md\", \"api.md\"]","category":"page"},{"location":"windows/#Windows","page":"Windows","title":"Windows","text":"","category":"section"},{"location":"windows/","page":"Windows","title":"Windows","text":"Windows, implemented via the AbstractWindow interface, are run within window managers, according to the AbstractWindowManager interface. Window managers manage all the information related to the execution of windows. They store active windows, connections to the display server (when applicable to the underlying windowing API), keymaps which are to be updated upon reception of specific events, and possibly more.","category":"page"},{"location":"windows/","page":"Windows","title":"Windows","text":"Typically, a program defines a single window manager, that manages one or several windows which can be created or closed at any given time. Then, an EventQueue may be created which wraps such a window manager; its role is to provide high-level events which the application can then process as it desires.","category":"page"}]
}
